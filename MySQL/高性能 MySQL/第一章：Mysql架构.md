---
title: 第一章：Mysql架构
lang: en-US
---

# 第一章：`Mysql`架构

`Mysql`的架构可以在不同的场景中应用并发挥的很好且很灵活；能适应不同的使用环境。同时，Mysql可以嵌入到应用系统中，也可以支持数据仓库、内容索引和部署软件、高可用的冗余系统、在线事务处理系统（OLTP）等应用。

`Mysql`最重要、最与众不同的特性是它的存储引擎架构，这种加架构的设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储、提取相分离。这种处理和存储分离设计可以在使用时根据性能、特性、以及其他需求来选择数据存储的方式。

## 1.1 MySQL 逻辑架构

**<p align='center'>MySQL 服务器逻辑架构图</p>**

![img](https://gitee.com/sue201982/mysql/raw/master/img/202111031053989.png)

最上层的服务：

大多数基于网络的客户端/服务端的工具或者服务都有类似的架构。连接处理、授权认证、安全等

- Connection Pool : 连接池组件

第二层的服务：

主要以`Mysql`的核心服务功能包括了查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

- Management Services & Utilities : 管理服务和工具组件
- SQL Interface : SQL接口组件
- Parser : 查询分析器组件
- Optimizer : 优化器组件
- Caches & Buffers : 缓冲池组件

第三层的服务：

存储引擎负责MySQL中数据的存储和提取。和 GNU/`Linux` 下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过 API 与存储引擎进行通信。这谢谢结构屏蔽了不同存储引擎之间的差异，使得这差异对上层查村过程透明。存储引擎 API 包含了几十个底层函数，用于执行诸如 “开始一个事务” 或 “根据主键提取一行数据” 等操作。但存储引擎不回去解析SSQL，不同存储引擎也不会相互通信，而只是简单地响应上层服务器的请求。

Mysql5.5之后的版本提供了一个API，支持线程池（Thread-Pooling）插件，可以使用池中少量的线程来服务大量的连接。

- Pluggable Storage Engines : 存储引擎
- File System : 文件系统

### 1.1.1 连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或CPU中运行。服务器会负责缓存线程，因此不需要为每个新建的连接创建或销毁线程。

当客户端（应用）连接到`Mysql`服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。如果使用安全套接字（SSL）的方式连接，还可以使用哦个 X.509 整数认证。一旦客户端连接成功，服务器就会继续验证该客户端是否具有执行某个特定查询的全新先。

### 1.1.2 优化与执行

`Mysql` 会解析查询寻，并创建内部数据结构（解析树），然后对其优化，包括重写查询、决定表的读取顺序、以及和合适的索引等。用户通过特殊的关键字提示（hint）优化器，影响其决策过程。也可以请求优化器解释（explain）优化过长城的各种因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置提高运行效率。

优化器不在乎什么存储引擎，但是存储引擎会影响优化查询。优化器请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。

对于 SELECT 语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果找到对应语句，服务器则不会执行查询解析、优化和执行整个过程，而是直接返回查询缓存中的结果。

## 1.2 并发控制

只要有多个查询在同一时间进行修改数据，就会产生**并发**控制的问题。以两个层面的方式考虑并发控制的问题：

- 服务器层
- 存储引擎层

### 1.2.1 读写锁

问题：

当同一时刻多个用户并发读取邮箱信息，但是某个客户正在读取邮件，同时另一个用户视图删除该邮件，会怎样？读取邮件的客户可能会报错从而退出，也可能读到不一致的邮箱数据。

如果解决：

在处理并发读或写时，可以通过实现一个有两种类型的锁组成的锁系统来解决问题。通常称为：

- 共享锁（shared lock）
- 排他锁（exclusive lock）

也叫：

- 读锁（read lock）
- 写锁（write lock）

概念为：

读锁为共享的，或者说互不阻塞的。多个用户在同一时刻可以同时读取同一个资源，而互不干扰。

写锁为排他的，也就是说一个写锁回阻塞去他的写锁和读锁，这是出于安全策略的考虑，只有这样才能确保在给定时间里，只有一个用户执行写入操作，并防止其他用户读取正在写入的资源。

在`Mysql`中锁的内部管理都是透明的。

### 1.2.2 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更具有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式为，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要互相之间不发生冲突即可。

但是加锁的也会消耗资源。锁的操作：获得锁、检查锁是否已经解除、释放锁等。都会增加系统的开销。如果消耗大量时间管理锁的而不是存取数据，系统性能会因此受到影响。

所谓的锁策略，就是锁的开销和安全性之间寻求平衡，这种平衡会影响性能。大多数商业数据库系统没有提供更多选择，一般都是在表上施加行级锁（row-level lock）。

`Mysql`提供了多种选择。每个存储引擎都可以实现自己的锁策略和锁粒度。

**表锁（table lock）**

表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。类似于之前描述的邮箱加锁机制：它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间不相互阻塞的。

例如：

Read Local 表锁支持某些类型的并发操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能被插入到读锁队列的前面。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。Ex：服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

**行级锁（row lock）**

行级锁可以最大程度的支持并发处理（同时也是开销最大的锁）。在`InnoDB`中实现了。行级锁只在存储引擎层实现，而`Mysql`服务器层没有。因为服务器曾完全不了解存储引擎中锁实现。

## 1.3 事务

事务就是一组原子性的SQL查询，或是一个独立的工作单元。

- **原子性（`Atmoicity` 不可分割性）**：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被滚回（rollback）到事务开始前的状态，就像这个事务没有执行过一样。
- **一致性（Consistency）**：在事务开始之前和事务结束后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定功能工作
- **隔离性（Isolation 独立性）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括了读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable Read）和串行化（Serializable）。
- **持久性（Durability）**：事务处理结束后，对数据修改就是永久的，即使系统故障也不会丢失。

事物的ACID可以确保事务可以成功执行而不会让数据丢失。而在应用逻辑中，要实现起来十分困难。一个兼容ACID的数据库系统，需要很多复杂但可能用户并没有察觉到的工作，才能确保ACID的实现。

和锁粒度类似，升级会增加系统开销一样，这种事务处理过程额外的安全性，也会需要数据库做更多的额外工作。

一个实现了ACID的数据库，相比没有实现ACID的数据库通常拥有更强大的CPU处理能力、更大的内存和更多的磁盘空间。根据不同的业务使用不同的存储引擎，以便提高性能。即使一些非事务型的存储引擎也可以通过 LOCK TABLES 提供一定的保护。

### 1.3.1 隔离级别（Isolation level）

SQL标准定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，那些在事务内和事务间可见的，那些不可见。较低级别的隔离通常可以执行更高的并发，系统开销更低。

隔离级别分类：

- **READ UNCOMMITTED（未提交读）**：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，为被称为**脏读（Dirty Read）**。这个级别会导致很多问题，从性能上来说，Read Uncommitted 不会比其他级别好太多，并且缺乏其他级别的很多优势，一般很少用这个。
- **READ COMMITTED（提交读）**：大部分数据库系统默认隔离级别都是 READ COMMITTED（Mysql不是）。Read Committed满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话来说，一个事务从开始直到提交之前，所做的任何修改对其他事务都不可见的。这个级别有时候也叫做**不可重复读（nonrepeatable read）**，因此两次执行同样的查询，可能会得到不一样的结果。
- **REPEATABLE READ（可重复读）**：REPEATABLE READ解决了脏读的问题。该级别保证了同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复隔离界别还是无法解决另外一个问题：**幻读（Phantom Read）**。所谓幻读，指的是当某个事物在读取某个范围的记录时，会产生**幻行（Phantom Row）**。多数的存储引擎通过版本并发控制（MVCC，Multi Version Concurrency Control）解决了这个问题。**可重复读是Mysql的默认事务隔离级别**
- **SERIALIZABLE（可串行化）**：SERIALIZABLE为最高隔离级别。其通过强制事务串行执行，避免了幻读问题。简单的来说，SERIALIZABLE会在读取每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用很少用这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

**<p algin="center">ANSI SQL 隔离级别</p>**

|     隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :--------------: | :--------: | :--------------: | :--------: | :----: |
| READ UNCOMMITTED |    Yes     |       Yes        |    Yes     |   No   |
|  READ COMMITTED  |     No     |       Yes        |    Yes     |   No   |
| REPEATABLE READ  |     No     |        No        |    Yes     |   No   |
|   SERIALIZABLE   |     No     |        No        |     No     |  Yes   |

### 1.3.2 死锁

定义：

指的是两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

当事务试图以不同的顺序锁定资源时，就会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

Ex：

事务一：

~~~mysql
START TRANSACTION;
UPDATE StockPrice SET close = 45.50 WHERE store_id = 4 AND date = '2001-05-01';
UPDATE StockPrice SET close = 19.80 WHERE store_id = 3 AND date = '2001-05-02';
COMMIT;
~~~

事务二：

~~~mysql
START TRANSACTION;
UPDATE StockPrice SET close = 20.12 WHERE store_id = 3 AND date = '2001-05-02';
UPDATE StockPrice SET close = 47.20 WHERE store_id = 4 AND date = '2001-05-01';
COMMIT;
~~~

如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条UPDATE语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才能解除死锁。

为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，如`InnoDB`存储引擎，越能检测到死锁的循环依赖，并立刻返回一个错误机制。这种解决方法很有效，否则死锁会导致出现查询过慢。另一种方法解决，就是在查询时达到锁等待超时的设定后放弃锁请求。`InnoDB`处理方法为：将持有最少行级排他锁的事务进行滚回。

锁的行为和存储引擎有关，同样的语句在不同的存储引擎会产生死锁，有的不会；原因：要么是数据冲突，要么是存储引擎的实现方式导致的。

死锁发生后，只有部分或完全回滚其中一个事务才能打破死锁。这是事务型系统无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。

### 1.3.3 事务日志

`Mysql`中提供的两种事务型的存储引擎：`InnoDB`和NDB Cluster。另外还有第三方引擎如：`XtraDB`和PBXT等。

**自动提交（AUTOCOMMIT）**

`Mysql`默认采用自动提交模式。也即是说，如果不是显式的开始一个事务，则每个查询都会被当作一个事务执行提交操作。在当前连接中，可以通过设置 AUTOCOMMITE 变量来启动或禁止自动提交事务。

~~~mysql
SHOW variables LIKE 'AUTOCOMMIT';
~~~

![image-20211108170338201](https://gitee.com/sue201982/mysql/raw/master/img/202111081703241.png)

1 或 ON 表示开启，0 或 OFF 表示是禁止。当AUTOCOMMIT = 0时，所有的查询都是在一个事务中，直到显示执行 COMMIT 提交或者 ROLLBACK 回滚，该事务结束，同时又开始另一个事务。

修改 AUTOCOMMIT 对非事务型的表，不会有任何影响。对这类表来说，没有 COMMIT 或 ROLLBACK 的概念，可以以说是相当于一直处于 AUTOCOMMIT 启用的模式。

还有一些命令再执行之前会强制执行 COMMIT 提交当前的活动事务。

`Mysql` 可以通过执行`SET TRANSACTION ISOLATION LEVEL` 命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以咋爱配置文件中设置整个数据库的隔离级别，也可以值改变当前会话的隔离级别：

~~~mysql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
~~~

![image-20211108171243057](https://gitee.com/sue201982/mysql/raw/master/img/202111081712083.png)

>`Mysql`可以识别所有的4个隔离级别。

**在事务中混合使用存储引擎**

`Mysql` 服务器不管理事务，事务由下层的存储引擎实现，所以在同一个事务使用不同的存储引擎并不可能。

如果在事务中混合使用了事务型和非事务型，正常提交并无太大问题。但是如果事务需要回滚，非事务型的表示无法变更的，导致数据库处于不一致状态，所以每张表都需要一个合适的存储引擎。

> 大多数情况非事务型表上执行事务时并不会报错，只有警告：‘某些非事务型表上的变更不能被回滚’。

**隐式和显示锁定**

`InnoDB`采用的是两阶段锁定协议（two-`place` locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或ROLLBACK时候才会被释放，并且所有的锁都是在同一时刻被释放。InnoDB 会根据隔离级别在需要的时候自动加锁。

另外，`InnoDB`支持通过特定语句进行显示锁定：

~~~mysql
SELECT ... LOCK IN SHARE MODE;
SELECT ... FOR UPDATE;
~~~

`Mysql` 支持`Lock Tables` 和`Unlock Tables` 语句，这是服务器层实现的，和存储引擎无关。但是并不能替代事务处理。如果引用需要用到事务，还是选择事务型存储引擎。

> Lock tables 和事务之间互相影响的话，会使情况变得复杂，建议除了事务中仅用了AUTOCOMMIT，可以使用LOCK TABLES之外，不要使用LOCK TABLES。

## 1.4 多版本并发控制

`Mysql`的大多数事务型存储引擎都不是简单的行级锁，而是基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。不仅仅只是`Mysql`，其余的数据库系统也一样，但是各自的实现机制并不相同。

可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了枷锁操作，因此开销更低。实现机制不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的**快照**来实现的。也就是说，不管需要执行多久时间，每个事物看到的数据都是一致的。根据事务的开时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

实现方法EX:

- 乐观（optimistic）并发控制
- 悲观（pessimistic）并发控制

**MVCC的工作原理**

`InnoDB` 的 MVCC 是通过每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建事件，一个保存行的过期时间（删除时间）。当然存储的并不是实际的时间值，而是系统版本号（System Version Number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到的每行记录的版本号进行比较。

`Ex：REPEATEABLE` READ 隔离级别下，MVCC具体操作

**SELECT：**

`InnoDB`会根据以下两个条件检查每行记录：

1.`InnoDB` 之查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事物的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是在事务自身插入或修改过的。
2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始前未被删除。

**INSERT：**

`InnoDB` 为新插入的每一行保存当前系统版本号作为行版本号。

**DELETE：**

`InnoDB`为删除的每一行保存当前版本号作为行删除标识。

**UPDATE：**

`InnoDB` 为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行所谓行删除标识符。

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及额外的维护工作。

MVCC只在 REPEATABLE READ 和 READ COMMITTED 这两个隔离级别下工作。其他两个隔离级别斗个MVCC不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的是数据行。而SERIALIZABLE则会对所有读取的行都加锁。

## 1.5 MySQL 存储引擎

在文件系统中，`Mysql` 将每个数据库（也称schema）保存为数据目录下的一个子目录。创建表时，`Mysql`会在数据库子目录下创建一个和表相同名的`.frm` 文件保存表的定义。因为`Mysql`使用文件系统的目录和文件夹保存数据库和表的定义，大小写敏感性和具体的平台密切相关。Window没有大小写区分。表的定义则是在`Mysql`服务层统一处理的。

~~~
Name|Engine|Version|Row_format|Rows|Avg_row_length|Data_length|Max_data_length|Index_length|Data_free|Auto_increment|Create_time        |Update_time|Check_time|Collation     |Checksum|Create_options|Comment|
----+------+-------+----------+----+--------------+-----------+---------------+------------+---------+--------------+-------------------+-----------+----------+--------------+--------+--------------+-------+
emp1|InnoDB|     10|Dynamic   |9999|           158|    1589248|              0|           0|        0|         10000|2021-11-01 16:20:53|           |          |gbk_chinese_ci|        |              |       |
~~~

通过`SHOW TABLE STATUS` 命令显示表的相关信息。

-`Name`：表名
-`Engine`：表存储引擎类型
-`Version`：版本
-`Row_format`：行的格式
-`Rows`：表中的行数，`InnoDB`中的值为估计值，`MyISAM`则是精确的
-`Avg_row_length`：平均每行包含的字节数
-`Data_length`：表数据的大小（以字节为单位）
-`Max_data_legnth`：表数据的最大容量，该值和存储引擎有关
-`Index_length`：索引的大小（以字节为单位）
-`Data_free`：表示已分配但目前没有使用的空间。
-`Auto_increment`：下一个 AUTO_INCREMENT 的值
-`Create_time`：表创建的时间
-`Update_time`：表数据最后修改时间
-`Check_time`：使用`CHECK TABLE`命令或`myisamchk`工具最后一次检查表的时间
-`Collation`：表的默认字符集和字符列排序规则
-`Checksum`：如果启用，保存的是整个表的实时校验和
-`Create_options`：创建表时指定的其他选项
-`Comment`：该列包含了一些其他额外信息

### 1.5.1 `InnoDB`存储引擎

`InnoDB` 引擎为`Mysql`的默认事务型引擎，也是使用最为广泛的存储引擎。其被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况是正常提交的，很少会被滚回。`InnoDB`的性能和自动崩溃恢复特性，使得其在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他存储引擎，优先考虑`InnoDB` 引擎。

![image-20211108200349855](https://gitee.com/sue201982/mysql/raw/master/img/202111082003923.png)

![image-20211108200420373](https://gitee.com/sue201982/mysql/raw/master/img/202111082004422.png)

![image-20211108200438228](https://gitee.com/sue201982/mysql/raw/master/img/202111082004250.png)

**InnoDB 概览**

`InnoDB` 的数据存储在表空间（tablespace）中，表空间是由 ·管理的黑盒子，由一系列的数据文件组成。在`Mysql` 4.1 后的版本，`InnoDB` 可以将每个表的数据和索引存放在单独的文件中。`InnoDB` 也可以使用裸设备作为空间的存储介质，但现代的文件系统是的裸设备不再是必要的选择。

`InnoDB`采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ（可重复读），并且通过**间隙锁（next-key locking）**策略防止**幻读**的出现。间隙锁使得`InnoDB` 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止**幻影行**的插入。

`InnoDB` 表是基于**聚簇索引**建立的。`InnoDB`的索引结构和`Mysql`和其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的索引也会很大。因此，若表上的索引较多的话，主键应当尽可能小。`InnoDB` 存储格式是平台独立的，也就是说可以将数据和索引文件从 Intel 平台复制到 PowerPC 或 Sun SPARC 平台。

`InnoDB` 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应**哈希索引（adaptive hash index）**，以及能够加速插入操作的**插入缓冲区（insert buffer）**等。

`InnoDB` 的行为十分复杂和难以理解的。 可参考官方的**`InnoDB`事务模型和锁**。

作为事务型存储引擎，`InnoDB`从过一些机制和工具支持真正的**热备份**，`Mysql`其他存储引擎并不支持热备份，要获取一致性视图要停止对所有表的写入，而在读写混合场景，停止写入可能也意味着停止读取。

### 1.5.2 `MyISAM` 存储引擎

在`Mysql` 5.1 之前的版本，`MyISAM`为默认的存储引擎。`MyISAM` 提供了大量的特性，包括全局索引、压缩、空间函数（GIS）等，但`MyISAM` 不支持事务和行级锁，而且有一个缺陷就是系统崩溃后无法安全恢复。正是因为`MyISAM`引擎的缘故，即使`Mysql`支持了事务很久但是却无法使用。

`MyISAM` 对于只读的数据，或表较小、可以忍受修复（repair）操作，则依然可以继续使用`MyISAM`。

**存储**

`MyISAM` 会将表存储在两个文件中：

- 数据文件
- 索引文件

分别以：`.MYD` 和`.MYI` 为扩展名。`MyISAM` 表可以包含动态或静态（长度固定）行。`Mysql` 会根据表的定义来决定采取何种行格式。`MyISAM`表可以存储的行记录数，一般受限于可用磁盘空间，或者操作系统中单个文件的最大尺寸。

在`Mysql` 5.0 中，`MyISAM`表如果是变长行，则默认配置处理356TB的数据，因为指向数据记录的指针长度为 6个字节。可以通过表的MAX_ROWS或AVG_ROW_LENGTH选项值来实现，两者相乘就是表可能达到的最大大小。修改这两个参数会导致重建整个表和索引。

**MyISAM 特性**

- `加锁与并发`：`MyISAM`对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表叫排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录（成为：并发插入，`CONCURRENT INSERT`）。
- `修复`：对于`MyISAM`表，`Mysql` 可以手动或自动执行检查和修复操作，这里的修复和事务恢复是不同的。执行表的修复肯能导致一些数据丢失，而且恢复很慢。通过`CHECK TABLE xxx`检查表的错误，有错误则通过`REPAIR TABLE xxxx`修复。如果服务器关闭可以通过 `myisamchk` 命令行工具进行检查和修复。
- `索引特性`：`MyISAM`表，即使`BLOB`和`TEXT`等长字段，可以基于前 500 个字符创建索引。`MyISAM` 支持全文索引，是一种基于分词建立的所哟i你，可以支持复杂查询。
- `延迟更新索引键（Delayed Key Write）`：在创建时，如果指定了`DELAY_KEY_WRITE`选项，在每次修改执行完成时，不会立刻修改索引数据写入磁盘，而是会写到内存中的键缓冲区（in-memory key buffer），只有在清理键缓冲区或关闭表时将对应索引块写入。既提高了性能，但是主机崩溃造成索引损坏需要执行修复操作。可全局配置或单个表设置

**`MyISAM` 压缩表**

如果表在创建并导入数据以后，不再进行修改操作则是和采用 - `MyISAM` 压缩表

可以使用 `myisampack` 对 `MyISAM` 表进行压缩（打包 pack）。压缩表不能进行修改（除非先将表解除压缩，修改数据，再次压缩）。压缩表可以极大减少磁盘空间占用，因此可以减少磁盘的 I/O，从而提升查询性能。并且也支持索引（只读）。

读取压缩表数据时解压带来的开销影响并不大，而减少 I/O 带来的好处大得多。压缩时表中的记录是独立压缩的，所以读取单行是不需要解压整个表。

**`MyISAM` 性能**

`MyISAM` 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。`MyISAM` 有一些服务器级别的性能扩张限制，比如对索引键缓冲区（key cache）的`Mutex`锁，MariaDB基于段（segment）的索引键缓冲区机制避免该问题。但 `MyISAM` 最典型的性能问题还是表锁问题。

### 1.5.3 `MySQL` 内建的其他存储引擎

**Archive引擎**

`Arehive`存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前也不支持索引。Archive引擎会缓存所有的写并利用`zlib`对插入的行进行压缩，所以比`MyISAM`表的磁盘I/O更少。但是每次SELECT查询都需要执行全表扫描。所以Archive表适合日志和数据采集类应用，这类应用做数据分析时往往需要全表扫描。或者在一些需要更快速的INSERT操作的场合下也可以使用。Archive引擎支持行级锁和专用的缓冲区，所以可以实现高并发的插人。在一个查询开始直到返回表中存在的所有行数之前，Archive引擎会阻止其他的SELECT执行，以实现一致性读。另外，也实现了批量插人在完成之前对读操作是不可见的。这种机制模仿了事务和MVCC的一些特性，但Archive引擎不是一个事务型的引擎，而是一个针对高速插人和压缩做了优化的简单引擎。

**Blackhole 引擎**

Blackhole引擎没有实现任何的存储机制，它会丢弃所有插人的数据，不做任何保存。但是服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志。这种特殊的存储引肇可以在一些特殊的复制架构和日志审核时发挥作用。但这种应用方式我们碰到过很多问题，因此并不推荐。

**CSV 引擎**

CSV引擎可以将普通的CSV文件(逗号分割值的文件)作为MySQL的表来处理，但这种表不支持索引。CSV引擎可以在数据库运行时拷人或者拷出文件。可以将Excel等电子表格软件中的数据存储为CSV文件，然后复制到MySQL数据目录下，就能在MySQL中打开使用。同样，如果将数据写人到一个CSV引擎表，其他的外部程序也能立即从表的数据文件中读取CSV格式的数据。因此CSV引擎可以作为一种数据交换的机制，非常有用。

**Federated 引擎**

Federated 引擎是访问其他MySQL服务器的一个代理，它会创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。最初设计该存储引擎是为了和企业级数据库如Microsoft SQL Server和Oracle的类似特性竞争的，可以说更多的是一种市场行为。尽管该引肇看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。MariaDB使用了它的一个后续改进版本，叫做`FederatedX`。

**Memory 引擎**

如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表(以前也叫做HEAP表)是非常有用的。Memory表至少比`MyISAM`表
要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。

`Memroy`表在很多场景可以发挥好的作用:

- 用于查找(lookup)或者映射(mapping)表，例如将邮编和州名映射的表。
- 用于缓存周期性聚合数据(periodically aggregated data)的结果。
- 用于保存数据分析中产生的中间数据。

Memory表支持Hash索引，因此查找操作非常快。虽然Memory表的速度非常快，但还是无法取代传统的基于磁盘的表。`Memroy`表是表级镇，因此井发写人的性能较低。它不支持BLOB或TEXT类型的列，并且每行的长度是固定的，所以即使指定了VARCHAR列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费(其中一些限制在`Percona`版本已经解决)

如果MySQL在执行查询的过程中需要使用临时表来保存中间结果，内部使用的临时表就是Memory表。如果中间结果太大超出了Memory表的限制，或者含有BLOB或TEXT字段，则临时表会转换成`MyISAM`表。

> 我们经常混淆 Memory 表和临时表。临时表是指使用CREATE TEMPORARY TABLE语句创建的表，它可以使用任何存储引擎，因此和Memory表不是一回事。临时表只在单个连接中可见，当连接断开时，临时表也将不复存在。

**Merge 引擎**

Merge引擎是`MyISAM`引擎的一个变种。Merge表是由多个`MyISAM`表合并而来的虚拟表。如果将MySQL用于日志或者数据仓库类应用，该引擎可以发挥作用。但是引入分区功能后，该引擎已经被放弃。

**NDB 集群引擎**

2003年，当时的`MySQLAB`公司从索尼爱立信公司收购了NDB数据库，然后开发了NDB集群存储引擎，作为SQL和NDB原生协议之间的接口。MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，被称为MySQL集群(MySQL Cluster)。

### 1.5.4 第三方存储引擎

![image-20211109173230957](https://gitee.com/sue201982/mysql/raw/master/5I2kyBh4mFCSN9Q.png)

**面向列的存储引擎**

MySQL默认是面向行的，每一行的数据是一起存储的，服务器的查询也是以行为单位处理的。而在大数据量处理时，面向列的方式可能效率更高。如果不需要整行的数据，面向列的方式可以传输更少的数据。如果每一列都单独存储，那么压缩的效率也会更高。

Infobright是最有名的面向列的存储引擎。在非常大的数据量(数十TB)时，该引擎工作良好。Infobright是为数据分析和数据仓库应用设计的。数据高度压缩，按照块进行排序，每个块都对应有一组元数据。在处理查询时，访问元数据可决定跳过该块，甚至可能只需要元数据即可满足查询的需求。但该引擎不支持索引，不过在这么大的数据量级，即使有索引也很难发挥作用，而且块结构也是一种准索引(quasi-index)。Infobright需要对MySQL服务器做定制，因为一些地方需要修改以适应面向列存储的需要。如果查询无法在存储层使用面向列的模式执行，则需要在服务器层转换成按行处理，这个过程会很慢。Infobright有社区版和商业版两个版本。

另外一个面向列的存储引擎是Calpont公司的InfiniDB，也有社区版和商业版。InfiniDB可以在一组机器集群间做分布式查询，但目前还没有生产环境的应用案例。
