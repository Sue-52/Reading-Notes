---
title: 附录B-Mysql的索引数据结构详解
lang: en-US
---

# 附录B-Mysql的索引数据结构详解

`MySQL` 支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此`MySQL`数据库支持多种索引类型，如：

- B-Tree索引
- 哈希索引
- 全文本索引

等等。

## 索引数据结构

- **数组和链表**：这是最为基本的数据结构，各自的劣势过于明显。数据库对查询寻要求是很高的，所以链表这种查询必须全表遍历的基本数据结构直接否决。数组这种结构在添加数据时消耗的成本太大了，插入数据时要考虑是否扩容。
- **hash表**：类似于hashmap，速度是快了，但是只要是hash就会产生无序的问题，不常用。
- **树**：二叉查找树：在查找一个数据时，二叉树是读取根节点，小则从左边查找，反之右边查找，每次读取一个数据。没办法合理的利用局部性原理与磁盘预读，IO次数太多，其次就是树的层级偏高。

而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

![img](https://gitee.com/sue201982/mysql/raw/master/img//1.png)

上图为一种可能的索引方式。左边为数据表，一共有两列七条记录，最左边的是数据记录的物理地址（逻辑上相邻的记录在磁盘上并不一定物理相邻）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log n)的复杂度获取到相应数据。

虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的。

## B-Tree（Balance Tree）

目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。

B-树是一种多路自平衡的搜索树。类似于普通的平衡二叉树，不同的是B-树允许每个节点有很多的子节点。

描述一个B-Tree：

首先，定义一条数据记录为一个二元组 `[key,data]`，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。

B-Tree要满足一下条件的数据结构：

- d 为大于1的一个正整数，称为`B-Tree`的度。
- h 为一个正整数，称为`B-Tree`的高度。
- 每个非叶子节点由 `n-1` 个 `key` 和 n 个指针组成，其中 `d<=n<=2d`。
- 每个叶子节点最少包含一个 `key` 和两个指针，最多包含 `2d-1` 个 `key` 和 2d 个指针，叶节点的指针指向的节点为 `Null`。
- 所有叶节点具有相同的深度，等于树高 h。
- `key` 和指针互相间隔，节点两端是指针。
- 一个节点中的 `key` 从左到右非递减排序。
- 所有节点组成树结构。
- 每个指针要么为 `Null`，要么指向另外一个节点。
- 如果某个指针在节点 `node` 最左边且不为 `Null`，则其指向节点的所有 `key` 小于 <img src="https://latex.codecogs.com/svg.image?v(key{1})" title="v(key{1})" />，其中 <img src="https://latex.codecogs.com/svg.image?v(key{1})" title="v(key{1})" /> 是 `node` 的 第一个 `key` 值。
- 如果某个指针在节点 `node` 最右边且不为 `Null`，则其指向节点的所有 `key` 大于 <img src="https://latex.codecogs.com/svg.image?v(key{m})" title="v(key{m})" />，其中 <img src="https://latex.codecogs.com/svg.image?v(key{m})" title="v(key{m})" /> 是 `node` 的 最后一个 `key` 值。
- 如果某个指针在节点 node 的左右相邻 key 分别为 <img src="https://latex.codecogs.com/svg.image?key{i}" title="key{i}" /> 和 <img src="https://latex.codecogs.com/svg.image?key{i&plus;1}" title="key{i+1}" /> 且不为 Null，则其指向节点的所有 `key` 在 <img src="https://latex.codecogs.com/svg.image?key{i}" title="key{i}" /> 和 <img src="https://latex.codecogs.com/svg.image?key{i&plus;1}" title="key{i+1}" /> 之间。

![20160202204827368](https://gitee.com/sue201982/mysql/raw/master/img//20160202204827368.png)

由于 `B-Tree` 的特性，在 `B-Tree` 中按 `key` 检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。

~~~c++
BTree_Search(node, key) {
    if(node == null) return null;
    foreach(node.key)
    {
        if(node.key[i] == key) return node.data[i];
            if(node.key[i] > key) return BTree_Search(point[i]->node);
    }
    return BTree_Search(point[i+1]->node);
}
data = BTree_Search(root, my_key);
~~~

关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。

另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。

## B+Tree

与 B-Tree 不同点是：

- 每个结点的指针上限为2d而不是2d+1。
- 内节点不存储data，只存储key；叶子节点不存储指针。

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwMjAyMjA1MTA1NTYw](https://gitee.com/sue201982/mysql/raw/master/img//aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwMjAyMjA1MTA1NTYw%20(1).png)

## 为什么使用 B-Tree 和 B+Tree

一般来说，索引本身也很大，不能全部存储在内存中，内次索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中要产生磁盘的I/O消耗，相对于内存的存取，I/O存取消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

### 主存存取原理

目前计算机使用的主存基本都是随机读取存储器（RAM），现代RAM的结构和存取原理是很复杂的。

![image](https://gitee.com/sue201982/mysql/raw/master/img//376141-20180508214608050-412122368.png)

从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，这里为简化的二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。这里为一个4X4的主存模型。

存取过程如下：

- 当系统需要去读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到执行存储单元，然后将存储单元数据放到数据总线上，供其它部件读取
- 写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。

可以看出，主存存取的事件仅与存取次数呈线性关系，因为不存在机械操作，两次读取的数据的'距离'不会对时间有任何影响。

### 磁盘存取原理

**（1）盘片、片面 和 磁头**

硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。

![clipboard](https://gitee.com/sue201982/mysql/raw/master/img//clipboard.png)

![clipboard1](https://gitee.com/sue201982/mysql/raw/master/img//clipboard1.png)

**（2）扇区 和 磁道**

下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）

![clipboard2](https://gitee.com/sue201982/mysql/raw/master/img//clipboard2.png)

通过磁头和磁道的接触，然后我们进行数据的读写

**（3）磁头 和 柱面**

硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 如下图

![clipboard3](https://gitee.com/sue201982/mysql/raw/master/img//clipboard3.png)

**3、磁盘容量计算**

存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数图3中磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，上图中每条磁道有12个扇区，所以此磁盘的容量为：存储容量 6 * 7 * 12 * 512 = 258048  

每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。

**4、磁盘读取响应时间**

1. 寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。
2. 旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。
3. 数据传输时间：完成传输所请求的数据所需要的时间。

**读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，软件应着重考虑减少寻道时间和延迟时间。（类似于CPU缓存行，把随机读改成顺序读写）**

**5、块/簇**

磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。每个块可以包括2、4、8、16、32、64…2的n次方个扇区。

**为什么存在磁盘块？**

读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。（就是类似于班级，小组等）

**6、page**

操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。

**7、扇区、块/簇、page的关系**

1. 扇区： 硬盘的最小读写单元

2. 块/簇： 是操作系统针对硬盘读写的最小单元

3. page： 是内存与操作系统之间操作的最小单元。

扇区 <= 块/簇 <= page

**8、计算机读取数据流程**

当需要从磁盘读取数据时，系统会将数据地址传给磁盘，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做 寻道 ，所耗费时间叫做 寻道时间 ，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做**旋转时间**。

### 局部性原理与磁盘预读

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的十万分之一，因此为了提高效率，要**尽量减少磁盘I/O**。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的**局部性原理**：

当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为**页（page）**的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

![clipboard4](https://gitee.com/sue201982/mysql/raw/master/img//clipboard4.png)

mysql的数据一般以文件形式存储在磁盘上，检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。

![clipboard5](https://gitee.com/sue201982/mysql/raw/master/img//clipboard5.png)

### B-/+Tree索引性能分析

先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

综上所述，用B-Tree作为索引结构效率是非常高的。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：

dmax=floor(pagesize/(keysize+datasize+pointsize))

floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。

## MyISAM 索引实现

MyISAM 引擎使用的是 B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，原理图：

![img](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/8.png)

这里设表一共有三列，假设我们以COl1为主键，则是一个MyISAM表的主键索引（Primary Key）示意。可以看出MyISAM索引文件仅保存数据记录地址。在MyISAM中，主索引和辅助索引（Secondary Key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的key可以重复。

这是在Col2上建立的辅助索引图：

![img](https://gitee.com/sue201982/mysql/raw/master/img//9.png)

同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法查找索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

MyISAM的索引方式叫做 “非聚集”的，反之InnoDB称之为：“聚集索引”。

## InnoDB 索引实现

InnoDB也使用了B+Tree作为索引结构，但是实现方法和MyISAM不同。

区别一：

InnoDB的数据文本本很就是所引文件。MyISAM是将数据问价和索引文件分离，索引文件仅保存数据记录地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDDB表数据文件本身就是主索引。

![img](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/10.png)

我们看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身就是按照主键聚集，所以InnoDB表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个唯一标识数据记录的列作为主键，如果不存在这类列，则MySQL自动为InnoDB生成一个隐式字段作为主键，这个字段长度为6字节，类型为增长型。

第二个与MyISAM不同的是辅助索引，InnoDB辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。

![img](https://gitee.com/sue201982/mysql/raw/master/img//11.png)

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

## 索引设计原则

​索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。

- 对查询频次较高，且数据量比较大的表建立索引。

- 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。

- 使用唯一索引，区分度越高，使用索引的效率越高。

- 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。

- 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。

- 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。
