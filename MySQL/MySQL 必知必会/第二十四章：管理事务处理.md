---
title: 第二十四章：管理事务处理
lang: en-US
---

# 第二十四章：管理事务处理

并非所有的数据库引擎都支持事务处理管理。`MyISAM` 和 `InnoDB` 前者不支持明确的事务处理管理，后者支持。

事务处理（transaction processing）：可以用来维护数据库的完整性，它保证了成批的Mysql操作要么完全执行，要么完全不执行。**良好的数据库设计模式都是关联的。**

**Ex：添加订单：**

1. 检查数据库中是否有相应的客户，如果不存在则添加。
2. 检索客户的ID
3. 添加一行到订单表，并把它和客户ID关联
4. 检索订单表中赋予的新订单ID
5. 对于订单的每个商品在订单商品表中添加一行，通过检索出来的ID把它和订单表关联

但是，某种原因数据库故障了（如：超出磁盘空间、安全限制、表锁等）阻止了过程的完成，会怎样呢？

如果故障发生在添加了客户之后，订单表添加之前，不会有什么问题。某些客户没有订单是完全合法的。在重新执行此过程时，所插入的客户记录将被检索和使用。可以有效地从出故障的地方开始执行此过程。

但是，如果故障发生在订单行添加之后，订单商品行添加之前，怎么办呢？现在，数据库中有一个空订单。

更糟的是，如果系统在添加订单商品行之中出现故障。结果是数据库中存在不完整的订单，而且你还不知道。

这时候就需要**事务处理**，它是一种机制，用来管理必须成批执行的Mysql操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。

相同的例子，如何工作：

1. 检查数据库中是否存在相应的客户，如果不存在，添加他/她。
2. 提交客户信息。
3. 检索客户的ID。
4. 添加一行到订单表。
5. 如果在添加行到订单表时出现故障，回退
6. 检索订单表中赋予的新订单ID。
7. 对于订购的每项物品，添加新行到订单商品表。
8. 如果在添加新行到订单商品时出现故障，回退所有添加的订单商品行和订单行。
9. 提交订单信息。

专业术语：

- 事务（transaction）：指一组SQL语句
- 回退（rollback）：指撤销指定SQL语句的过程
- 提交（commmit）：指将为存储的SQL语句将结果写入数据库表
- 保留点（savepoint）：指事务处理中设置的临时占位符（placeholder），你可以对它发布退回（与退回整个事务处理不同）。

## 控制事务处理

管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。

一般来说，事务必须满足4个条件（ACID）：

- 原子性（Atmoicity 不可分割性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被滚回（rollback）到事务开始前的状态，就像这个事务没有执行过一样。
- 一致性（Consistency）：在事务开始之前和事务结束后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定功能工作
- 隔离性（Isolation 独立性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括了读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable Read）和串行化（Serializable）。
- 持久性（Durability）：事务处理结束后，对数据修改就是永久的，即使系统故障也不会丢失。

开始标识事务语句：

~~~mysql
START TRANSACTION;
~~~

### 使用 ROLLBACK

Mysql 的 ROLLBACK 命令用来回退（撤销）Mysql语句。

~~~mysql
SELECT * FROM products; -- 选择所有商品
START TRANSACTION; -- 开启事务处理
DELETE FROM products WHERE prod_id ='XCE05'; -- 删除
SELECT * FROM products; -- 查看：空
ROLLBACK; -- 退回
SELECT * FROM products; -- 查看：还原了数据
~~~

显然，ROLLBACK 只能在一个事务处理内使用（（在执行一条START TRANSACTION命令之后）。

> 那些语句可以退回：事务处理用来管理 INSERT、UPDATE、DELETE语句。无法退回SELECT语句（没有意义），也不能退回CREATE和DROP操作。事务处理块中可以使用，但是如果执行退回，它们不会被撤销。

### 使用 COMMIT

Mysql的语句都是直接针对数据库表执行和编写的。这就是所谓的`隐含提交（implicit commit）`，即提交（写或保存）操作都是自动进行的。

但是，在事务处理中，提交不会隐含的进行。为了进行明确的提交，使用 `COMMIT` 语句。

~~~mysql
START TRANSACTION;
DELETE FROM orderitems WHERE order_num = 20010;
DELETE FROM orders WHERE order_num = 20010;
COMMIT;
~~~

在这个例子中，从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。

> 隐含事务关闭：当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）


### 使用保留点 SAVEPOINT

简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。

例如，前面描述的添加订单的过程为一个事务处理。如果发生错误，只需要返回到添加orders行之前即可，不需要回退到customers表（如果存在的话）。

为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。

这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT语句：

~~~mysql
SAVEPOINT identifier;
~~~

删除保留点：

~~~mysql
RELEASE SAVEPOINT identifier;
~~~

将事务回滚到标记点：

~~~mysql
ROLLBACK TO identifier
~~~

每个保留点都要取标识它唯一的名字，以便在退回时，Mysql知道要退回到哪里。

> **保留点越多越好** 可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿灵活地进行回退.
> **释放保留点** 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。

### 更改默认的提交行为

默认的Mysql行为时自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：

SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

~~~mysql
SET AUTOCOMMIT = 0; -- 禁止自动提交
SET AUTOCOMMIT = 1; -- 开启自动提交
~~~

`autocommit` 标志决定是否自动提交更改，不管有没有 COMMIT 语句。

> **标志为连接专用**：autocommit 标志是针对每个连接而不是服务器。

